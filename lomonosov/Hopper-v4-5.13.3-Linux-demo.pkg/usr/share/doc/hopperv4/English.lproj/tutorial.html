<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta name="description" content="Tutorial" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="width=700" />
		<title>Scripts</title>
		<link rel="stylesheet" type="text/css" media="screen,print" href="../shared/styles/style.css" />
	</head>
	<body>
<script type="text/javascript">
if (document.getElementById("tuto_tab") == null) {
    window.location = "./Hopper.html#tuto";
}
</script>

        <!-- Embedded starts here -->

        <div class="tutorial">
            <!-- ----------------------------------------------------------------------- -->

            <a name="presentation"></a>
            <h2 id="presentation">Presentation</h2>
            <p>
                Hopper is a tool that will assist you in your static analysis of executable files.
            </p>
            <p>
                This quick presentation will give you a good overview of what is Hopper, and how it works.
            </p>
            <p>
                Hopper is a rich-featured application, and all cannot be discussed here, but don’t worry, you’ll quickly
                find your marks, and easily discover all its subtleties.
            </p><img src="../shared/tutorial_files/overview@1x.jpg" srcset="../shared/tutorial_files/overview@2x.jpg 2x" alt="">
            <p>
                The interface is split into three main areas:
            </p>
            <ul>
                <li>
                    <strong>The left pane</strong> contains a list of all the symbols defined in the file, and the list
                    strings. The list can be filtered using <em>tags</em> and <em>text</em>.
                </li>
                <li>
                    <strong>The right pane</strong> is called the inspector. It contains contextual information about
                    the explored area.
                </li>
                <li>
                    <strong>The center part</strong> is where the assembly language, and its various representations are displayed.
                </li>
            </ul>

            <!-- ----------------------------------------------------------------------- -->

            <a name="concept"></a>
            <h2 id="theconcept">The Concept</h2>
            <p>
                The idea behind Hopper is to transform a set of bytes (the binary you want to analyze) into something
                that could be read by a human.
            </p>
            <p>
                To do so, Hopper will try to <strong>associate a type to each byte of the file</strong>. Because it
                would be much too expensive to do it manually, Hopper proceeds to an automatic analysis as soon as you
                loaded a file.
            </p>
            <p>
                The various types that can be used in hopper are:
            </p>
            <ul>
                <li>
                    <strong>Data</strong>: an area is set to the <em>data</em> type when Hopper thinks it is an area
                    that represents a constant, like an array of <em>int</em> for instance.
                </li>
                <li>
                    <strong>ASCII</strong>: a NULL-terminated C string.
                </li>
                <li>
                    <strong>Code</strong>: an instruction
                </li>
                <li>
                    <strong>Procedure</strong>: a byte receives this type once it has been determinate that it is part
                    of a method that has been successfully reconstructed by Hopper.
                </li>
                <li>
                    <strong>Undefined</strong>: this is an area that has not yet been explored by Hopper,
                </li>
            </ul>
            <p>
                As soon as an executable is loaded, you can manually change the type, by using either the keyboard, or
                the toolbar on top of the window.
            </p><img src="../shared/tutorial_files/toolbar@1x.jpg" srcset="../shared/tutorial_files/toolbar@2x.jpg 2x" alt="">
            <p>
                The toolbar contains one button by type you can set (<strong>D</strong> for <em>data</em>,
                <strong>A</strong> for <em>ASCII</em>, etc.). These letters are also the keyboard shortcut you can
                directly use.).
            </p>
            <p>
                The <em>data</em> type has a little specific behavior: the first time you use this type, Hopper will
                transform the area into a byte. If you use it again, the byte will be transformed into a 16 bits
                integer, then a 32 bits integer, and so on…
            </p>
            <p>
                Feel free to play with transformations to explore the executable: Hopper provides an <strong>undo /
                redo</strong> feature.
            </p>

            <!-- ----------------------------------------------------------------------- -->

            <a name="modes"></a>
            <h1 id="display_modes">Display Modes</h1>

            <p>
                Reading assembly language is a little bit difficult, and boring in some cases.
                In order to help you, Hopper can use different kinds of representations for the code.
            </p>

            <p>
                Most of them require the construction of a procedure, because procedures contain additional
                information about the structure of the code, like basic blocks, or stack usage.
            </p>
            <p>
                The current mode can be changed using the toolbar:
            </p>
            <img src="../shared/tutorial_files/modes_toolbar@1x.jpg" srcset="../shared/tutorial_files/modes_toolbar@2x.jpg 2x" alt="">

            <a name="asm"></a>
            <h2>Assembly </h2>
            <p>
                The first mode is the <strong>Assembly Mode</strong>. Hopper prints the lines of assembly code, one
                after the other. This is what most disassemblers provide.
            </p>
            <img src="../shared/tutorial_files/mode_asm@1x.jpg" srcset="../shared/tutorial_files/mode_asm@2x.jpg 2x" alt="">
            <p>
                The first column (blue numbers) represents the addresses of the instructions. In front of each of them,
                the instruction, and its operands (or arguments). As an option, in the preferences of the application,
                you can choose to print the instruction encoding between the address, and the instruction mnemonic.
            </p>
            <p>
                In the margin, you'll see some colored arrows. These arrows represent the possible destination of a
                jump instruction. For instance, on the above screenshot, the blue arrow between addresses
                <strong>0x100002d82</strong>, and <strong>0x100002db4</strong> represents the fact that the instruction
                <strong>je</strong> at <strong>0x100002d82</strong> may jump to the address <strong>0x100002db4</strong>
                if the conditions are met.
                When an instruction jumps to a greater address (a forward jump), the arrow is drawn in blue. If the jump
                goes forward, the arrow is drawn in red.
            </p>
            <p>Note that, in this representation, if you click in the red column, you'll set a breakpoint at the
                corresponding address, and if you click in the blue column, you'll set a bookmark.
            </p>

            <a name="cfg"></a>
            <h2>Control Flow Graph</h2>
            <p>
                The <strong>CFG mode</strong> represent a procedure in a more structured way.
            </p>
            <img src="../shared/tutorial_files/mode_cfg@1x.jpg" srcset="../shared/tutorial_files/mode_cfg@2x.jpg 2x" alt="">

            <p>
                You can still edit things in this representation, like comments and labels. The cursor can be moved from
                one basic block to another; simply move the cursor to the bound of the current basic block, and use
                the arrow key of your keyboard to jump to the nearest basic block. If you press the up, or down key, the
                cursor will move to the nearest basic block, <strong>but keeping the same column</strong>.
                For instance, in the following case, the cursor will move like indicated:
            </p>
            <img src="../shared/tutorial_files/mode_cfg_jmp@1x.jpg" srcset="../shared/tutorial_files/mode_cfg_jmp@2x.jpg 2x" alt="">
            <p>
                The same behavior applies for the left, and right keys.
            </p>
            <p>
                In the right panel (the inspector), you'll find a section dedicated to the mode. The
                <strong>Control Flow Graph</strong> component displays a smaller representation of the current procedure,
                called <strong>minimap</strong>.
                Each square represents a basic block, and lines are drawn to represents their connections.
                One of them is filled in blue: this is the basic block containing the cursor.
                A light gray square represents the current portion of the method drawn in the main part. You can move
                the viewport by clicking direcly in this map.
            </p>
            <img src="../shared/tutorial_files/mode_minimap@1x.jpg" srcset="../shared/tutorial_files/mode_minimap@2x.jpg 2x" alt="">

            <p>
                The nodes of the graph can be modified. For instance, it is possible to group some of them when you
                think that they are closely related. Select the nodes, and click on the <strong>Group Nodes</strong>
                button in the inspector.
            </p>
            <img src="../shared/tutorial_files/mode_cfg_group@1x.jpg" srcset="../shared/tutorial_files/mode_cfg_group@2x.jpg 2x" alt="">
            <p>
                You can also set a custom background color to a given node, or edit the printed text.
            </p>

            <a name="pseudocode"></a>
            <h2>Pseudo-Code</h2>
            <p>
                In this representation, Hopper will try to produce some pseudo-code, functionally equivalent to the
                original CPU instructions, but more or less like an Objective-C method.
            </p>
            <img src="../shared/tutorial_files/mode_pseudocode@1x.jpg" srcset="../shared/tutorial_files/mode_pseudocode@2x.jpg 2x" alt="">
            <p>
                This is clearly the easiest way of reading code you are analyzing, but you should remind that there is
                no magic: sometimes, it is not possible to construct a perfect pseudo-code representation of a procedure,
                and some parts may disappear, because Hopper wrongly thought that it was unreachable code (also called
                <strong>dead code</strong>). In order to mitigate this problem, you can try to toggle the corresponding
                checkbox at the top of the view.
            </p>

            <a name="hex"></a>
            <h2>Hex Mode</h2>
            <p>
                This mode allows you to take a look directly at the bytes of the file.
            </p>
            <img src="../shared/tutorial_files/mode_hex@1x.jpg" srcset="../shared/tutorial_files/mode_hex@2x.jpg 2x" alt="">
            <p>
                The first column represents the offset in the file, and the other columns, each of the bytes.
                When you put the cursor on a byte, you'll notice that the selection automatically extends to the left,
                and to the right. Indeed, Hopper knows more about the file than any regular hexadecimal editor, and for
                instance, on the previous screenshot, Hopper knows that the cursor is inside an instruction, and selects
                all of its bytes.
            </p>
            <p>
                If you double-click on a byte, you can change its value. In some case, it may destroy the underneath
                structure. For instance, if your cursor was in an instruction, the instruction is automatically destroyed,
                and the associated Hopper's type falls back to the <strong>undefined</strong> state. Also, if the instruction
                was part of a procedure, the procedure is destroyed. Anyway, keep in mind that you can always roll back
                your changes, as Hopper provides an undo / redo feature.
            </p>
            <p>
                The number of columns in this representation depends on the width of the window; this is the default
                behavior, but this can be changed in the application preferences. For instance, you can force Hopper
                to always display 16 columns, whatever is the width of the window.
            </p>

            <!-- ----------------------------------------------------------------------- -->

            <a name="navigation"></a>
            <h1 id="navigatingthroughthefile">
                Navigating Through the File
            </h1>
            <h2 id="segmentsandsections">
                Segments and Sections
            </h2>
            <p>
                An executable file is split into smaller pieces of data, called <strong>segments</strong>, and
                <strong>sections</strong>.
            </p>
            <p>
                When the operating system loads an executable, some parts of its bytes are mapped into memory. Each
                contiguous piece of the file mapped into memory is called <strong>segments</strong>. These segments are
                split into smaller parts, called <strong>sections</strong>, which will receive various access
                properties.
            </p>
            <p>
                You can navigate through these objects by using the <strong>Navigate &gt; Show Segment List</strong> and
                <strong>Navigate &gt; Show Section List</strong> menu items.
            </p>
            <h2 id="symbolstagsandstrings">
                Symbols, Tags and Strings
            </h2>
            <p>
                Because it would be too difficult to remember the address where each piece of code lies into the
                executable, you can affect <strong>names</strong>, or <strong>symbols</strong> to the addresses.
            </p>
            <p>
                To name an address, you just need to put the cursor on the address, and press <strong>N</strong>. A
                dialog will pop up: simply type the name you want to set.
            </p>
            <p>
                The symbol list is accessible in the left pane of the window.
            </p><img src="../shared/tutorial_files/symbol_list@1x.jpg" srcset="../shared/tutorial_files/symbol_list@2x.jpg 2x" alt="">
            <p>
                Using the <em>search field</em>, you can filter the symbols listed below. Hopper uses a kind of regular
                expression to filter the list; first, it will present the items that completely contain the term you
                wrote. Then, right below, the list of symbols that contain one text insertion, then two insertions, and
                so on. This is what I called the <em>fuzzy search</em>, and this behavior can be disabled in the
                preferences of the application.
            </p>
            <p>
                You can use the <strong>tags</strong> to filter even more efficiently the symbol list. Tags are textual
                information that can be put on an address, a basic-block of a procedure, or a whole procedure. You can
                open the <strong>Tag Scope</strong> element to see all tags that exists in the current document. If you
                select a tag, only procedures that contain this tag will be listed. Note that if you close the <strong>Tag
                Scope</strong> item, the filter is reset to <em>all tags</em>.
            </p>
            <p>
                An interesting thing to note is that many tags are automatically generated during the loading process of
                an executable. For instance, every entry points will receive a specific <strong>entrypoint</strong> tag,
                and each implementation of each Objective-C class will be tagged with the name of the class (or
                category). It allows you to quickly navigate through code written in Objective-C!
            </p>
            <p>
                You can choose to display the <strong>strings</strong> contained in the file. In this mode, only the
                ASCII strings are displayed, and the <strong>Tag Scope</strong> has no effect.
            </p>
            <h2 id="thenavigationstack">
                The Navigation Stack
            </h2>
            <p>
                You can jump to an address, or a symbol by <strong>double-clicking</strong> on it. The address where the
                cursor was located, is pushed on a stack. You pop this stack, and navigate back by using the <strong>escape
                key</strong> or the <strong>backspace key</strong> on your keyboard. You can also use the navigation
                toolbar items.
            </p><img src="../shared/tutorial_files/navigation@1x.jpg" srcset="../shared/tutorial_files/navigation@2x.jpg 2x" alt="">
            <p>
                The right arrow will jump to the address under the cursor, and the left arrow will come back.
            </p>
            <h2 id="thenavigationbar">
                The Navigation Bar
            </h2>
            <p>
                Just above the assembly, you’ll find the <strong>navigation bar</strong>.
            </p><img src="../shared/tutorial_files/navigator@1x.jpg" srcset="../shared/tutorial_files/navigator@2x.jpg 2x" alt="">
            <p>
                This bar is used to quickly navigate into the file. A color scheme is used to indicate the various types
                given to the bytes of the file.
            </p>
            <ul>
                <li>
                    <strong>Blue</strong> parts represent code,
                </li>
                <li>
                    <strong>Yellow</strong> parts represent procedures,
                </li>
                <li>
                    <strong>Green</strong> parts represent ASCII strings,
                </li>
                <li>
                    <strong>Purple</strong> parts represent data,
                </li>
                <li>
                    <strong>Grey</strong> parts are undefined.
                </li>
            </ul>
            <p>
                A little <strong>red arrow</strong> indicates where the cursor is currently located.
            </p>
            <h2 id="usingtheinspector">
                Using the Inspector
            </h2>
            <p>
                The <strong>inspector</strong> is the rightmost part of the window. It contains various components that
                will show up, or hidden depending on the context where the cursor is currently located.
            </p><img src="../shared/tutorial_files/inspector@1x.jpg" srcset="../shared/tutorial_files/inspector@2x.jpg 2x" alt="">
            <p>
                Here is a quick overview of the components that you can find in the inspector:
            </p>
            <h3 id="instructionencoding">
                Instruction Encoding
            </h3>
            <p>
                This component displays the bytes of the current instruction. If the current processor has multiple CPU
                modes (like the <em>ARM</em> and <em>Thumb</em> modes of the <em>ARM</em> processor family), you’ll see
                a popup menu that lets you change the CPU mode at the current address.
            </p>
            <h3 id="format">
                Format
            </h3>
            <p>
                This component is used to change the display format of the operand of an instruction. You can choose
                between <em>signed / unsigned hexadecimal</em>, <em>decimal</em>, <em>octal</em>, <em>address</em>, etc.
            </p>
            <h3 id="comment">
                Comment
            </h3>
            <p>
                You can associate a textual comment at a given address. Use this component to edit this comment.
            </p>
            <h3 id="colorsandtags">
                Colors and Tags
            </h3>
            <p>
                This component lets you associate <strong>tags</strong> to addresses, basic-block of a procedure, or a
                procedure. Those tags are useful to navigate efficiently through the file.
            </p>
            <p>
                You can even put some colors on addresses in order to quickly, and visually, distinguish parts of the
                executable.
            </p>
            <h3 id="references">
                References
            </h3>
            <p>
                This is a very important component; it <strong>shows all the references</strong> that one instruction
                can have to another instruction, or piece of data. It contains the references in the other way too, <em>i.e.</em>,
                the other instructions that references this one. You can even <strong>add your own references</strong>
                by hand if the analysis performed by Hopper didn’t find some references.
            </p>
            <h3 id="procedure">
                Procedure
            </h3>
            <p>
                This component contains the information on the current procedure. For each basic-block, it displays the
                list of its predecessors and its successors.
            </p>
            <p>
                At the bottom of the component, you’ll find a very useful button: <strong>Switch/case hint</strong>.
                This button is enabled on instructions like *<em>jmp REGISTER</em>. It allows you to help Hopper to find
                the statements of a <em>switch/case</em> construction.
            </p><img src="../shared/tutorial_files/switch_hint@1x.jpg" srcset="../shared/tutorial_files/switch_hint@2x.jpg 2x" alt="">

            <!-- ----------------------------------------------------------------------- -->

            <a name="modifications"></a>
            <h1 id="modifyingthefile">
                Modifying the File
            </h1>
            <h2 id="thehexadecimaleditor">
                The Hexadecimal Editor
            </h2>
            <p>
                As previously seen, Hopper provides a <strong>hexadecimal editor</strong>. The editor is synchronized
                with the assembly language view, and automatically highlights bytes that are part of the current instruction.
            </p><img src="../shared/tutorial_files/hexedit@1x.jpg" srcset="../shared/tutorial_files/hexedit@2x.jpg 2x" alt="">
            <p>
                Double-click on a byte to modify it. You can use the Undo/Redo feature if you made a mistake.
            </p>
            <h2 id="theassembler">
                The Assembler
            </h2>
            <p>
                An embedded assembler can be invoked from Hopper from the <strong>Modify &gt; Assemble
                Instruction…</strong> menu.
            </p><img src="../shared/tutorial_files/assembler@1x.jpg" srcset="../shared/tutorial_files/assembler@2x.jpg 2x" alt="">
            <p>
                You can also use the <strong>Modify &gt; NOP Region</strong> menu to replace the currently selected
                instructions by NOP instructions.
            </p><!-- -->
        </div> <!-- tutorial -->

        <!-- Embedded ends here -->

</body>
</html>
